var N = null;var searchIndex = {};
searchIndex["bigint"]={"doc":"Efficient large, fixed-size big integers and hashes.","items":[[0,"uint","bigint","Big unsigned integer types.",N,N],[3,"U128","bigint::uint","Little-endian large integer type",N,N],[12,"0","","",0,N],[3,"U256","","Little-endian large integer type",N,N],[12,"0","","",1,N],[3,"U512","","Little-endian large integer type",N,N],[12,"0","","",2,N],[4,"FromDecStrErr","","Conversion from decimal string error",N,N],[13,"InvalidCharacter","","Char not from range 0-9",3,N],[13,"InvalidLength","","Value does not fit into type",3,N],[11,"fmt","","",3,[[["self"],["formatter"]],["result"]]],[11,"eq","","",3,[[["self"],["fromdecstrerr"]],["bool"]]],[11,"clone","","",0,[[["self"]],["u128"]]],[11,"eq","","",0,[[["self"],["u128"]],["bool"]]],[11,"ne","","",0,[[["self"],["u128"]],["bool"]]],[11,"hash","","",0,N],[18,"MAX","","",0,N],[11,"from_dec_str","","Convert from a decimal string.",0,[[["str"]],["result",["fromdecstrerr"]]]],[11,"low_u32","","Conversion to u32",0,[[["self"]],["u32"]]],[11,"low_u64","","Conversion to u64",0,[[["self"]],["u64"]]],[11,"as_u32","","Conversion to u32 with overflow checking",0,[[["self"]],["u32"]]],[11,"as_u64","","Conversion to u64 with overflow checking",0,[[["self"]],["u64"]]],[11,"is_zero","","Whether this is zero.",0,[[["self"]],["bool"]]],[11,"bits","","Return the least number of bits needed to represent the number",0,[[["self"]],["usize"]]],[11,"bit","","Return if specific bit is set.",0,[[["self"],["usize"]],["bool"]]],[11,"leading_zeros","","Returns the number of leading zeros in the binary representation of self.",0,[[["self"]],["u32"]]],[11,"trailing_zeros","","Returns the number of leading zeros in the binary representation of self.",0,[[["self"]],["u32"]]],[11,"byte","","Return specific byte.",0,[[["self"],["usize"]],["u8"]]],[11,"to_big_endian","","Write to the slice in big-endian format.",0,N],[11,"to_little_endian","","Write to the slice in little-endian format.",0,N],[11,"to_hex","","Convert to hex string.",0,[[["self"]],["string"]]],[11,"exp10","","Create `10**n` as this type.",0,[[["usize"]],["self"]]],[11,"zero","","Zero (additive identity) of this type.",0,[[],["self"]]],[11,"one","","One (multiplicative identity) of this type.",0,[[],["self"]]],[11,"max_value","","The maximum value which can be inhabited by this type.",0,[[],["self"]]],[11,"pow","","Fast exponentation by squaring https://en.wikipedia.org/wiki/Exponentiation_by_squaring",0,[[["self"],["self"]],["self"]]],[11,"overflowing_pow","","Fast exponentation by squaring https://en.wikipedia.org/wiki/Exponentiation_by_squaring",0,N],[11,"overflowing_add","","Optimized instructions",0,N],[11,"saturating_add","","Addition which saturates at the maximum value.",0,[[["self"],["u128"]],["u128"]]],[11,"overflowing_sub","","Subtraction which underflows and returns a flag if it does.",0,N],[11,"saturating_sub","","Subtraction which saturates at zero.",0,[[["self"],["u128"]],["u128"]]],[11,"overflowing_mul","","Multiply with overflow, returning a flag if it does.",0,N],[11,"saturating_mul","","Multiplication which saturates at the maximum value..",0,[[["self"],["u128"]],["u128"]]],[11,"overflowing_div","","Division with overflow",0,N],[11,"overflowing_rem","","Modulus with overflow.",0,N],[11,"overflowing_neg","","Negation with overflow.",0,N],[11,"from_big_endian","","Converts from big endian representation bytes in memory Can also be used as (&slice).into(), as it is default `From` slice implementation for U256",0,N],[11,"from_little_endian","","Converts from little endian representation bytes in memory",0,N],[11,"default","","",0,[[],["self"]]],[11,"from","","",0,[[["u64"]],["u128"]]],[11,"from","","",0,[[["u8"]],["u128"]]],[11,"from","","",0,[[["u16"]],["u128"]]],[11,"from","","",0,[[["u32"]],["u128"]]],[11,"from","","",0,[[["usize"]],["u128"]]],[11,"from","","",0,[[["i64"]],["u128"]]],[11,"from","","",0,[[["i8"]],["u128"]]],[11,"from","","",0,[[["i16"]],["u128"]]],[11,"from","","",0,[[["i32"]],["u128"]]],[11,"from","","",0,[[["isize"]],["u128"]]],[11,"from","","",0,N],[11,"from_str","","",0,[[["str"]],["result",["u128"]]]],[11,"add","","",0,[[["self"],["u128"]],["u128"]]],[11,"sub","","",0,[[["self"],["u128"]],["u128"]]],[11,"mul","","",0,[[["self"],["u128"]],["u128"]]],[11,"div","","",0,[[["self"],["u128"]],["u128"]]],[11,"rem","","",0,[[["self"],["u128"]],["u128"]]],[11,"bitand","","",0,[[["self"],["u128"]],["u128"]]],[11,"bitxor","","",0,[[["self"],["u128"]],["u128"]]],[11,"bitor","","",0,[[["self"],["u128"]],["u128"]]],[11,"not","","",0,[[["self"]],["u128"]]],[11,"shl","","",0,[[["self"],["usize"]],["u128"]]],[11,"shr","","",0,[[["self"],["usize"]],["u128"]]],[11,"cmp","","",0,[[["self"],["u128"]],["ordering"]]],[11,"partial_cmp","","",0,[[["self"],["u128"]],["option",["ordering"]]]],[11,"fmt","","",0,[[["self"],["formatter"]],["result"]]],[11,"fmt","","",0,[[["self"],["formatter"]],["result"]]],[11,"fmt","","",0,[[["self"],["formatter"]],["result"]]],[11,"from","","",0,[[["str"]],["self"]]],[11,"clone","","",1,[[["self"]],["u256"]]],[11,"eq","","",1,[[["self"],["u256"]],["bool"]]],[11,"ne","","",1,[[["self"],["u256"]],["bool"]]],[11,"hash","","",1,N],[18,"MAX","","",1,N],[11,"from_dec_str","","Convert from a decimal string.",1,[[["str"]],["result",["fromdecstrerr"]]]],[11,"low_u32","","Conversion to u32",1,[[["self"]],["u32"]]],[11,"low_u64","","Conversion to u64",1,[[["self"]],["u64"]]],[11,"as_u32","","Conversion to u32 with overflow checking",1,[[["self"]],["u32"]]],[11,"as_u64","","Conversion to u64 with overflow checking",1,[[["self"]],["u64"]]],[11,"is_zero","","Whether this is zero.",1,[[["self"]],["bool"]]],[11,"bits","","Return the least number of bits needed to represent the number",1,[[["self"]],["usize"]]],[11,"bit","","Return if specific bit is set.",1,[[["self"],["usize"]],["bool"]]],[11,"leading_zeros","","Returns the number of leading zeros in the binary representation of self.",1,[[["self"]],["u32"]]],[11,"trailing_zeros","","Returns the number of leading zeros in the binary representation of self.",1,[[["self"]],["u32"]]],[11,"byte","","Return specific byte.",1,[[["self"],["usize"]],["u8"]]],[11,"to_big_endian","","Write to the slice in big-endian format.",1,N],[11,"to_little_endian","","Write to the slice in little-endian format.",1,N],[11,"to_hex","","Convert to hex string.",1,[[["self"]],["string"]]],[11,"exp10","","Create `10**n` as this type.",1,[[["usize"]],["self"]]],[11,"zero","","Zero (additive identity) of this type.",1,[[],["self"]]],[11,"one","","One (multiplicative identity) of this type.",1,[[],["self"]]],[11,"max_value","","The maximum value which can be inhabited by this type.",1,[[],["self"]]],[11,"pow","","Fast exponentation by squaring https://en.wikipedia.org/wiki/Exponentiation_by_squaring",1,[[["self"],["self"]],["self"]]],[11,"overflowing_pow","","Fast exponentation by squaring https://en.wikipedia.org/wiki/Exponentiation_by_squaring",1,N],[11,"overflowing_add","","Optimized instructions",1,N],[11,"saturating_add","","Addition which saturates at the maximum value.",1,[[["self"],["u256"]],["u256"]]],[11,"overflowing_sub","","Subtraction which underflows and returns a flag if it does.",1,N],[11,"saturating_sub","","Subtraction which saturates at zero.",1,[[["self"],["u256"]],["u256"]]],[11,"overflowing_mul","","Multiply with overflow, returning a flag if it does.",1,N],[11,"saturating_mul","","Multiplication which saturates at the maximum value..",1,[[["self"],["u256"]],["u256"]]],[11,"overflowing_div","","Division with overflow",1,N],[11,"overflowing_rem","","Modulus with overflow.",1,N],[11,"overflowing_neg","","Negation with overflow.",1,N],[11,"from_big_endian","","Converts from big endian representation bytes in memory Can also be used as (&slice).into(), as it is default `From` slice implementation for U256",1,N],[11,"from_little_endian","","Converts from little endian representation bytes in memory",1,N],[11,"default","","",1,[[],["self"]]],[11,"from","","",1,[[["u64"]],["u256"]]],[11,"from","","",1,[[["u8"]],["u256"]]],[11,"from","","",1,[[["u16"]],["u256"]]],[11,"from","","",1,[[["u32"]],["u256"]]],[11,"from","","",1,[[["usize"]],["u256"]]],[11,"from","","",1,[[["i64"]],["u256"]]],[11,"from","","",1,[[["i8"]],["u256"]]],[11,"from","","",1,[[["i16"]],["u256"]]],[11,"from","","",1,[[["i32"]],["u256"]]],[11,"from","","",1,[[["isize"]],["u256"]]],[11,"from","","",1,N],[11,"from_str","","",1,[[["str"]],["result",["u256"]]]],[11,"add","","",1,[[["self"],["u256"]],["u256"]]],[11,"sub","","",1,[[["self"],["u256"]],["u256"]]],[11,"mul","","",1,[[["self"],["u256"]],["u256"]]],[11,"div","","",1,[[["self"],["u256"]],["u256"]]],[11,"rem","","",1,[[["self"],["u256"]],["u256"]]],[11,"bitand","","",1,[[["self"],["u256"]],["u256"]]],[11,"bitxor","","",1,[[["self"],["u256"]],["u256"]]],[11,"bitor","","",1,[[["self"],["u256"]],["u256"]]],[11,"not","","",1,[[["self"]],["u256"]]],[11,"shl","","",1,[[["self"],["usize"]],["u256"]]],[11,"shr","","",1,[[["self"],["usize"]],["u256"]]],[11,"cmp","","",1,[[["self"],["u256"]],["ordering"]]],[11,"partial_cmp","","",1,[[["self"],["u256"]],["option",["ordering"]]]],[11,"fmt","","",1,[[["self"],["formatter"]],["result"]]],[11,"fmt","","",1,[[["self"],["formatter"]],["result"]]],[11,"fmt","","",1,[[["self"],["formatter"]],["result"]]],[11,"from","","",1,[[["str"]],["self"]]],[11,"clone","","",2,[[["self"]],["u512"]]],[11,"eq","","",2,[[["self"],["u512"]],["bool"]]],[11,"ne","","",2,[[["self"],["u512"]],["bool"]]],[11,"hash","","",2,N],[18,"MAX","","",2,N],[11,"from_dec_str","","Convert from a decimal string.",2,[[["str"]],["result",["fromdecstrerr"]]]],[11,"low_u32","","Conversion to u32",2,[[["self"]],["u32"]]],[11,"low_u64","","Conversion to u64",2,[[["self"]],["u64"]]],[11,"as_u32","","Conversion to u32 with overflow checking",2,[[["self"]],["u32"]]],[11,"as_u64","","Conversion to u64 with overflow checking",2,[[["self"]],["u64"]]],[11,"is_zero","","Whether this is zero.",2,[[["self"]],["bool"]]],[11,"bits","","Return the least number of bits needed to represent the number",2,[[["self"]],["usize"]]],[11,"bit","","Return if specific bit is set.",2,[[["self"],["usize"]],["bool"]]],[11,"leading_zeros","","Returns the number of leading zeros in the binary representation of self.",2,[[["self"]],["u32"]]],[11,"trailing_zeros","","Returns the number of leading zeros in the binary representation of self.",2,[[["self"]],["u32"]]],[11,"byte","","Return specific byte.",2,[[["self"],["usize"]],["u8"]]],[11,"to_big_endian","","Write to the slice in big-endian format.",2,N],[11,"to_little_endian","","Write to the slice in little-endian format.",2,N],[11,"to_hex","","Convert to hex string.",2,[[["self"]],["string"]]],[11,"exp10","","Create `10**n` as this type.",2,[[["usize"]],["self"]]],[11,"zero","","Zero (additive identity) of this type.",2,[[],["self"]]],[11,"one","","One (multiplicative identity) of this type.",2,[[],["self"]]],[11,"max_value","","The maximum value which can be inhabited by this type.",2,[[],["self"]]],[11,"pow","","Fast exponentation by squaring https://en.wikipedia.org/wiki/Exponentiation_by_squaring",2,[[["self"],["self"]],["self"]]],[11,"overflowing_pow","","Fast exponentation by squaring https://en.wikipedia.org/wiki/Exponentiation_by_squaring",2,N],[11,"overflowing_add","","Optimized instructions",2,N],[11,"saturating_add","","Addition which saturates at the maximum value.",2,[[["self"],["u512"]],["u512"]]],[11,"overflowing_sub","","Subtraction which underflows and returns a flag if it does.",2,N],[11,"saturating_sub","","Subtraction which saturates at zero.",2,[[["self"],["u512"]],["u512"]]],[11,"overflowing_mul","","Multiply with overflow, returning a flag if it does.",2,N],[11,"saturating_mul","","Multiplication which saturates at the maximum value..",2,[[["self"],["u512"]],["u512"]]],[11,"overflowing_div","","Division with overflow",2,N],[11,"overflowing_rem","","Modulus with overflow.",2,N],[11,"overflowing_neg","","Negation with overflow.",2,N],[11,"from_big_endian","","Converts from big endian representation bytes in memory Can also be used as (&slice).into(), as it is default `From` slice implementation for U256",2,N],[11,"from_little_endian","","Converts from little endian representation bytes in memory",2,N],[11,"default","","",2,[[],["self"]]],[11,"from","","",2,[[["u64"]],["u512"]]],[11,"from","","",2,[[["u8"]],["u512"]]],[11,"from","","",2,[[["u16"]],["u512"]]],[11,"from","","",2,[[["u32"]],["u512"]]],[11,"from","","",2,[[["usize"]],["u512"]]],[11,"from","","",2,[[["i64"]],["u512"]]],[11,"from","","",2,[[["i8"]],["u512"]]],[11,"from","","",2,[[["i16"]],["u512"]]],[11,"from","","",2,[[["i32"]],["u512"]]],[11,"from","","",2,[[["isize"]],["u512"]]],[11,"from","","",2,N],[11,"from_str","","",2,[[["str"]],["result",["u512"]]]],[11,"add","","",2,[[["self"],["u512"]],["u512"]]],[11,"sub","","",2,[[["self"],["u512"]],["u512"]]],[11,"mul","","",2,[[["self"],["u512"]],["u512"]]],[11,"div","","",2,[[["self"],["u512"]],["u512"]]],[11,"rem","","",2,[[["self"],["u512"]],["u512"]]],[11,"bitand","","",2,[[["self"],["u512"]],["u512"]]],[11,"bitxor","","",2,[[["self"],["u512"]],["u512"]]],[11,"bitor","","",2,[[["self"],["u512"]],["u512"]]],[11,"not","","",2,[[["self"]],["u512"]]],[11,"shl","","",2,[[["self"],["usize"]],["u512"]]],[11,"shr","","",2,[[["self"],["usize"]],["u512"]]],[11,"cmp","","",2,[[["self"],["u512"]],["ordering"]]],[11,"partial_cmp","","",2,[[["self"],["u512"]],["option",["ordering"]]]],[11,"fmt","","",2,[[["self"],["formatter"]],["result"]]],[11,"fmt","","",2,[[["self"],["formatter"]],["result"]]],[11,"fmt","","",2,[[["self"],["formatter"]],["result"]]],[11,"from","","",2,[[["str"]],["self"]]],[11,"full_mul","","Multiplies two 256-bit integers to produce full 512-bit integer No overflow possible",1,[[["self"],["u256"]],["u512"]]],[11,"mod_inverse","","Find modular inverse by modulo p",1,[[["self"],["self"]],["self"]]],[11,"from","","",2,[[["u256"]],["u512"]]],[11,"from","","",1,[[["u512"]],["u256"]]],[11,"from","","",2,[[["u256"]],["u512"]]],[11,"from","","",1,[[["u512"]],["u256"]]],[11,"from","","",0,[[["u256"]],["u128"]]],[11,"from","","",0,[[["u512"]],["u128"]]],[11,"from","","",2,[[["u128"]],["u512"]]],[11,"from","","",1,[[["u128"]],["u256"]]],[11,"from","","",1,N],[11,"from","","",1,N],[11,"from","","",0,N],[11,"from","","",0,N],[11,"from","","",2,N],[11,"from","","",2,N]],"paths":[[3,"U128"],[3,"U256"],[3,"U512"],[4,"FromDecStrErr"]]};
searchIndex["byteorder"]={"doc":"This crate provides convenience methods for encoding and decoding numbers in either [big-endian or little-endian order].","items":[[4,"BigEndian","byteorder","Defines big-endian serialization.",N,N],[4,"LittleEndian","","Defines little-endian serialization.",N,N],[6,"BE","","A type alias for [`BigEndian`].",N,N],[6,"LE","","A type alias for [`LittleEndian`].",N,N],[6,"NetworkEndian","","Defines network byte order serialization.",N,N],[6,"NativeEndian","","Defines system native-endian serialization.",N,N],[8,"ByteOrder","","`ByteOrder` describes types that can serialize integers as bytes.",N,N],[10,"read_u16","","Reads an unsigned 16 bit integer from `buf`.",0,N],[11,"read_u24","","Reads an unsigned 24 bit integer from `buf`, stored in u32.",0,N],[10,"read_u32","","Reads an unsigned 32 bit integer from `buf`.",0,N],[11,"read_u48","","Reads an unsigned 48 bit integer from `buf`, stored in u64.",0,N],[10,"read_u64","","Reads an unsigned 64 bit integer from `buf`.",0,N],[10,"read_uint","","Reads an unsigned n-bytes integer from `buf`.",0,N],[10,"write_u16","","Writes an unsigned 16 bit integer `n` to `buf`.",0,N],[11,"write_u24","","Writes an unsigned 24 bit integer `n` to `buf`, stored in u32.",0,N],[10,"write_u32","","Writes an unsigned 32 bit integer `n` to `buf`.",0,N],[11,"write_u48","","Writes an unsigned 48 bit integer `n` to `buf`, stored in u64.",0,N],[10,"write_u64","","Writes an unsigned 64 bit integer `n` to `buf`.",0,N],[10,"write_uint","","Writes an unsigned integer `n` to `buf` using only `nbytes`.",0,N],[11,"read_i16","","Reads a signed 16 bit integer from `buf`.",0,N],[11,"read_i24","","Reads a signed 24 bit integer from `buf`, stored in i32.",0,N],[11,"read_i32","","Reads a signed 32 bit integer from `buf`.",0,N],[11,"read_i48","","Reads a signed 48 bit integer from `buf`, stored in i64.",0,N],[11,"read_i64","","Reads a signed 64 bit integer from `buf`.",0,N],[11,"read_int","","Reads a signed n-bytes integer from `buf`.",0,N],[11,"read_f32","","Reads a IEEE754 single-precision (4 bytes) floating point number.",0,N],[11,"read_f64","","Reads a IEEE754 double-precision (8 bytes) floating point number.",0,N],[11,"write_i16","","Writes a signed 16 bit integer `n` to `buf`.",0,N],[11,"write_i24","","Writes a signed 24 bit integer `n` to `buf`, stored in i32.",0,N],[11,"write_i32","","Writes a signed 32 bit integer `n` to `buf`.",0,N],[11,"write_i48","","Writes a signed 48 bit integer `n` to `buf`, stored in i64.",0,N],[11,"write_i64","","Writes a signed 64 bit integer `n` to `buf`.",0,N],[11,"write_int","","Writes a signed integer `n` to `buf` using only `nbytes`.",0,N],[11,"write_f32","","Writes a IEEE754 single-precision (4 bytes) floating point number.",0,N],[11,"write_f64","","Writes a IEEE754 double-precision (8 bytes) floating point number.",0,N],[10,"read_u16_into","","Reads unsigned 16 bit integers from `src` into `dst`.",0,N],[10,"read_u32_into","","Reads unsigned 32 bit integers from `src` into `dst`.",0,N],[10,"read_u64_into","","Reads unsigned 64 bit integers from `src` into `dst`.",0,N],[11,"read_i16_into","","Reads signed 16 bit integers from `src` to `dst`.",0,N],[11,"read_i32_into","","Reads signed 32 bit integers from `src` into `dst`.",0,N],[11,"read_i64_into","","Reads signed 64 bit integers from `src` into `dst`.",0,N],[11,"read_f32_into_unchecked","","Reads IEEE754 single-precision (4 bytes) floating point numbers from `src` into `dst`.",0,N],[11,"read_f64_into_unchecked","","Reads IEEE754 single-precision (4 bytes) floating point numbers from `src` into `dst`.",0,N],[10,"write_u16_into","","Writes unsigned 16 bit integers from `src` into `dst`.",0,N],[10,"write_u32_into","","Writes unsigned 32 bit integers from `src` into `dst`.",0,N],[10,"write_u64_into","","Writes unsigned 64 bit integers from `src` into `dst`.",0,N],[11,"write_i16_into","","Writes signed 16 bit integers from `src` into `dst`.",0,N],[11,"write_i32_into","","Writes signed 32 bit integers from `src` into `dst`.",0,N],[11,"write_i64_into","","Writes signed 64 bit integers from `src` into `dst`.",0,N],[11,"write_f32_into","","Writes IEEE754 single-precision (4 bytes) floating point numbers from `src` into `dst`.",0,N],[11,"write_f64_into","","Writes IEEE754 double-precision (8 bytes) floating point numbers from `src` into `dst`.",0,N],[10,"from_slice_u16","","Converts the given slice of unsigned 16 bit integers to a particular endianness.",0,N],[10,"from_slice_u32","","Converts the given slice of unsigned 32 bit integers to a particular endianness.",0,N],[10,"from_slice_u64","","Converts the given slice of unsigned 64 bit integers to a particular endianness.",0,N],[11,"from_slice_i16","","Converts the given slice of signed 16 bit integers to a particular endianness.",0,N],[11,"from_slice_i32","","Converts the given slice of signed 32 bit integers to a particular endianness.",0,N],[11,"from_slice_i64","","Converts the given slice of signed 64 bit integers to a particular endianness.",0,N],[10,"from_slice_f32","","Converts the given slice of IEEE754 single-precision (4 bytes) floating point numbers to a particular endianness.",0,N],[10,"from_slice_f64","","Converts the given slice of IEEE754 double-precision (8 bytes) floating point numbers to a particular endianness.",0,N],[11,"clone","","",1,[[["self"]],["bigendian"]]],[11,"fmt","","",1,[[["self"],["formatter"]],["result"]]],[11,"hash","","",1,N],[11,"cmp","","",1,[[["self"],["bigendian"]],["ordering"]]],[11,"eq","","",1,[[["self"],["bigendian"]],["bool"]]],[11,"partial_cmp","","",1,[[["self"],["bigendian"]],["option",["ordering"]]]],[11,"default","","",1,[[],["bigendian"]]],[11,"clone","","",2,[[["self"]],["littleendian"]]],[11,"fmt","","",2,[[["self"],["formatter"]],["result"]]],[11,"hash","","",2,N],[11,"cmp","","",2,[[["self"],["littleendian"]],["ordering"]]],[11,"eq","","",2,[[["self"],["littleendian"]],["bool"]]],[11,"partial_cmp","","",2,[[["self"],["littleendian"]],["option",["ordering"]]]],[11,"default","","",2,[[],["littleendian"]]],[11,"read_u16","","",1,N],[11,"read_u32","","",1,N],[11,"read_u64","","",1,N],[11,"read_uint","","",1,N],[11,"write_u16","","",1,N],[11,"write_u32","","",1,N],[11,"write_u64","","",1,N],[11,"write_uint","","",1,N],[11,"read_u16_into","","",1,N],[11,"read_u32_into","","",1,N],[11,"read_u64_into","","",1,N],[11,"write_u16_into","","",1,N],[11,"write_u32_into","","",1,N],[11,"write_u64_into","","",1,N],[11,"from_slice_u16","","",1,N],[11,"from_slice_u32","","",1,N],[11,"from_slice_u64","","",1,N],[11,"from_slice_f32","","",1,N],[11,"from_slice_f64","","",1,N],[11,"read_u16","","",2,N],[11,"read_u32","","",2,N],[11,"read_u64","","",2,N],[11,"read_uint","","",2,N],[11,"write_u16","","",2,N],[11,"write_u32","","",2,N],[11,"write_u64","","",2,N],[11,"write_uint","","",2,N],[11,"read_u16_into","","",2,N],[11,"read_u32_into","","",2,N],[11,"read_u64_into","","",2,N],[11,"write_u16_into","","",2,N],[11,"write_u32_into","","",2,N],[11,"write_u64_into","","",2,N],[11,"from_slice_u16","","",2,N],[11,"from_slice_u32","","",2,N],[11,"from_slice_u64","","",2,N],[11,"from_slice_f32","","",2,N],[11,"from_slice_f64","","",2,N]],"paths":[[8,"ByteOrder"],[4,"BigEndian"],[4,"LittleEndian"]]};
searchIndex["crunchy"]={"doc":"The crunchy unroller - deterministically unroll constant loops. For number \"crunching\".","items":[[14,"unroll","crunchy","Unroll the given for loop",N,N]],"paths":[]};
searchIndex["ng"]={"doc":"","items":[],"paths":[]};
searchIndex["ng_curve"]={"doc":"Library for elliptic curve generalization","items":[[3,"AffinePoint","ng_curve","Affine point on the curve C",N,N],[3,"JacobianPoint","","Point on the curve C in jacobian representation",N,N],[11,"clone","","",0,[[["self"]],["point"]]],[11,"eq","","",0,[[["self"],["point"]],["bool"]]],[11,"ne","","",0,[[["self"],["point"]],["bool"]]],[11,"fmt","","",0,[[["self"],["formatter"]],["result"]]],[11,"infinity","","Point at infinity.",0,[[],["self"]]],[11,"is_infinity","","Test if point is at infinity.",0,[[["self"]],["bool"]]],[11,"new","","New point from two field elements",0,N],[11,"x","","Field element of X coordinate",0,N],[11,"y","","Field element of Y coordinate",0,N],[11,"into_parts","","Deconstruct point into field elements (X, Y)",0,N],[11,"from","","",0,N],[11,"from","","",0,[[["jacobianpoint"]],["self"]]],[11,"add","","",0,N],[11,"mul","","",0,[[["self"],["i"]],["self"]]],[11,"clone","","",1,[[["self"]],["point"]]],[11,"fmt","","",1,[[["self"],["formatter"]],["result"]]],[11,"eq","","",1,[[["self"],["point"]],["bool"]]],[11,"ne","","",1,[[["self"],["point"]],["bool"]]],[11,"from","","",1,[[["affinepoint"]],["self"]]],[11,"from","","",1,N],[11,"into_parts","","Deconstruct point into (X, Y, Z) parts",1,N],[11,"infinity","","New point at infinity",1,[[],["self"]]],[11,"is_infinity","","Test if point is at infinity",1,[[["self"]],["bool"]]],[11,"mul","","",1,[[["self"],["i"]],["self"]]],[11,"add","","",1,[[["self"],["i"]],["self"]]],[8,"Curve","","Generalization of a y^2 = x^2 + ax + b curve",N,N],[16,"Value","","Field element type of the curve",2,N],[10,"generator","","Generator point of the curve",2,[[],["point"]]],[10,"a","","a-parameter of the curve",2,N]],"paths":[[3,"AffinePoint"],[3,"JacobianPoint"],[8,"Curve"]]};
searchIndex["ng_field"]={"doc":"Abstract field and field element operations implementation","items":[[3,"FieldElement","ng_field","Field element on the field F with value V",N,N],[3,"MontgomeryElement","","Field element on the field F with value V in montgomery representation",N,N],[11,"fmt","","",0,[[["self"],["formatter"]],["result"]]],[11,"eq","","",0,[[["self"],["fieldelement"]],["bool"]]],[11,"ne","","",0,[[["self"],["fieldelement"]],["bool"]]],[11,"clone","","",0,[[["self"]],["fieldelement"]]],[11,"into_value","","Deconstruct and return raw value",0,N],[11,"add","","",0,N],[11,"sub","","",0,N],[11,"neg","","",0,N],[11,"mul","","",0,N],[11,"mul","","",0,[[["self"],["u32"]],["self"]]],[11,"div","","",0,N],[11,"from","","",0,[[["v"]],["self"]]],[11,"one","","Multiplication identity",0,[[],["self"]]],[11,"zero","","Additive identity",0,[[],["self"]]],[11,"clone","","",1,[[["self"]],["montgomeryelement"]]],[11,"fmt","","",1,[[["self"],["formatter"]],["result"]]],[11,"eq","","",1,[[["self"],["montgomeryelement"]],["bool"]]],[11,"ne","","",1,[[["self"],["montgomeryelement"]],["bool"]]],[11,"one","","Multiplication identity",1,[[],["self"]]],[11,"zero","","Additive identity",1,[[],["self"]]],[11,"from_element","","New field element from regular form",1,[[["fieldelement"]],["self"]]],[11,"into_element","","Convert to regular form",1,[[["self"]],["fieldelement"]]],[11,"into_value","","Deconstruct and return raw value (not reduced)",1,N],[11,"into_reduced_value","","Deconstruct and return raw value (not reduced)",1,N],[11,"add","","",1,N],[11,"sub","","",1,N],[11,"neg","","",1,N],[11,"mul","","",1,N],[11,"mul","","",1,[[["self"],["u32"]],["self"]]],[11,"div","","",1,N],[11,"from","","",1,[[["v"]],["self"]]],[8,"MulReduce","","Modular multiplication with reduction",N,N],[10,"mul_reduce","","Modular multiplication followed by reduction",2,[[["self"],["self"],["self"],["self"]],["self"]]],[8,"ModMul","","Modular multiplication.",N,N],[10,"mul","","Multiplication of self by other of the same type",3,[[["self"],["t"],["self"]],["self"]]],[8,"ModAdd","","Modular addition",N,N],[10,"add","","Addition of self with other of the same type",4,[[["self"],["self"],["self"]],["self"]]],[8,"ModInv","","Modular multiplicative inverse",N,N],[10,"inv","","Calculate modular multiplicative inverse",5,[[["self"],["self"]],["self"]]],[8,"ModNeg","","Modular negation",N,N],[10,"neg","","Negation of self by the modulus",6,[[["self"],["self"]],["self"]]],[8,"Scalar","","Scalar interface",N,N],[10,"one","","Multiplicative identity",7,[[],["self"]]],[10,"zero","","Addition identity",7,[[],["self"]]],[10,"bit","","Get nth bit",7,[[["self"],["usize"]],["bool"]]],[10,"max_bits","","Get total bit",7,[[],["usize"]]],[11,"bits","","Get bits iterator",7,[[["self"]],["bitsiterator"]]],[8,"Field","","Abstract field description",N,N],[16,"Value","","Type of scalar",8,N],[18,"MODULUS","","Field modulus",8,N],[18,"R","","Field montgomery coefficient (R)",8,N],[18,"R_INVERSE","","Multiplicative inverse of R modulus MODULUS",8,N],[8,"FieldValue","","Generalization of field element",N,N],[16,"Value","","Inner scalar value type of field element",9,N],[11,"squared","","Squared field element",9,[[["self"]],["self"]]],[11,"pow","","self^other",9,N],[10,"one","","Multiplication identity",9,[[],["self"]]],[10,"zero","","Additive identity",9,[[],["self"]]],[18,"MODULUS","","Field modulus",8,N],[18,"R","","Field montgomery coefficient (R)",8,N],[18,"R_INVERSE","","Multiplicative inverse of R modulus MODULUS",8,N],[11,"squared","","Squared field element",9,[[["self"]],["self"]]],[11,"pow","","self^other",9,N],[11,"bits","","Get bits iterator",7,[[["self"]],["bitsiterator"]]]],"paths":[[3,"FieldElement"],[3,"MontgomeryElement"],[8,"MulReduce"],[8,"ModMul"],[8,"ModAdd"],[8,"ModInv"],[8,"ModNeg"],[8,"Scalar"],[8,"Field"],[8,"FieldValue"]]};
searchIndex["ng_p256"]={"doc":"","items":[[3,"P256Field","ng_p256","",N,N],[3,"P256Curve","","",N,N],[11,"clone","","",0,[[["self"]],["p256field"]]],[11,"fmt","","",0,[[["self"],["formatter"]],["result"]]],[11,"eq","","",0,[[["self"],["p256field"]],["bool"]]],[11,"from_str","","",0,[[["str"]],["montgomeryelement"]]],[11,"from_hex","","",0,[[["str"]],["montgomeryelement"]]],[11,"from_u64","","",0,[[["u64"]],["montgomeryelement"]]],[11,"clone","","",1,[[["self"]],["p256curve"]]],[11,"fmt","","",1,[[["self"],["formatter"]],["result"]]],[11,"eq","","",1,[[["self"],["p256curve"]],["bool"]]],[11,"generator","","",1,[[],["affinepoint"]]],[11,"a","","",1,N]],"paths":[[3,"P256Field"],[3,"P256Curve"]]};
searchIndex["ng_polynomial"]={"doc":"Polynomials on finite fields library","items":[[3,"Polynomial","ng_polynomial","Represents polynomial on the finite field of members type T",N,N],[11,"clone","","",0,[[["self"]],["polynomial"]]],[11,"eq","","",0,[[["self"],["polynomial"]],["bool"]]],[11,"ne","","",0,[[["self"],["polynomial"]],["bool"]]],[11,"fmt","","",0,[[["self"],["formatter"]],["result"]]],[11,"new","","New polynomial with the set of coefficients",0,[[["i"]],["self"]]],[11,"one","","\"One\" polynomial (multiplicative identity for the ring)",0,[[],["self"]]],[11,"zero","","Zero polynomial (additive identity for the ring)",0,[[],["self"]]],[11,"interpolate","","Lagrange interpolation",0,N],[11,"eval","","Evaluate polynomial on t",0,[[["self"],["i"]],["t"]]],[11,"into_coefs","","Turn polynomial into the array of degrees",0,[[["self"]],["vec"]]],[11,"mul","","",0,[[["self"],["self"]],["self"]]],[11,"mul","","",0,[[["self"],["t"]],["self"]]],[11,"add","","",0,[[["self"],["self"]],["self"]]]],"paths":[[3,"Polynomial"]]};
searchIndex["ng_secp256k1"]={"doc":"","items":[[3,"Secp256k1Field","ng_secp256k1","",N,N],[3,"Secp256k1Curve","","",N,N],[11,"clone","","",0,[[["self"]],["secp256k1field"]]],[11,"fmt","","",0,[[["self"],["formatter"]],["result"]]],[11,"eq","","",0,[[["self"],["secp256k1field"]],["bool"]]],[11,"from_str","","",0,[[["str"]],["fieldelement"]]],[11,"from_u64","","",0,[[["u64"]],["fieldelement"]]],[11,"clone","","",1,[[["self"]],["secp256k1curve"]]],[11,"fmt","","",1,[[["self"],["formatter"]],["result"]]],[11,"eq","","",1,[[["self"],["secp256k1curve"]],["bool"]]],[11,"generator","","",1,[[],["affinepoint"]]],[11,"a","","",1,N]],"paths":[[3,"Secp256k1Field"],[3,"Secp256k1Curve"]]};
searchIndex["ng_uint"]={"doc":"","items":[[3,"U256","ng_uint","",N,N],[12,"0","","",0,N],[11,"clone","","",0,[[["self"]],["u256"]]],[11,"fmt","","",0,[[["self"],["formatter"]],["result"]]],[11,"eq","","",0,[[["self"],["u256"]],["bool"]]],[11,"ne","","",0,[[["self"],["u256"]],["bool"]]],[11,"from_raw","","",0,N],[11,"from_hex","","",0,[[["str"]],["self"]]],[11,"mul","","",0,[[["self"],["self"],["self"]],["self"]]],[11,"add","","",0,[[["self"],["self"],["self"]],["self"]]],[11,"mul_reduce","","",0,[[["self"],["self"],["self"],["self"]],["self"]]],[11,"neg","","",0,[[["self"],["self"]],["self"]]],[11,"inv","","",0,[[["self"],["self"]],["self"]]],[11,"mul","","",0,[[["self"],["u32"],["self"]],["self"]]],[11,"rem","","",0,[[["self"],["self"]],["self"]]],[11,"from","","",0,[[["str"]],["self"]]],[11,"one","","",0,[[],["self"]]],[11,"zero","","",0,[[],["self"]]],[11,"max_bits","","",0,[[],["usize"]]],[11,"bit","","",0,[[["self"],["usize"]],["bool"]]]],"paths":[[3,"U256"]]};
searchIndex["rustc_hex"]={"doc":"Hex binary-to-text encoding","items":[[4,"FromHexError","rustc_hex","Errors that can occur when decoding a hex encoded string",N,N],[13,"InvalidHexCharacter","","The input contained a character not part of the hex format",0,N],[13,"InvalidHexLength","","The input had an invalid length",0,N],[8,"ToHex","","A trait for converting a value to hexadecimal encoding",N,N],[10,"to_hex","","Converts the value of `self` to a hex value, returning the owned string.",1,[[["self"]],["string"]]],[8,"FromHex","","A trait for converting hexadecimal encoded values",N,N],[10,"from_hex","","Converts the value of `self`, interpreted as hexadecimal encoded data, into an owned vector of bytes, returning the vector.",2,[[["self"]],["result",["vec","fromhexerror"]]]],[11,"clone","","",0,[[["self"]],["fromhexerror"]]],[11,"fmt","","",0,[[["self"],["formatter"]],["result"]]],[11,"description","","",0,[[["self"]],["str"]]],[11,"fmt","","",0,[[["self"],["formatter"]],["result"]]]],"paths":[[4,"FromHexError"],[8,"ToHex"],[8,"FromHex"]]};
initSearch(searchIndex);
